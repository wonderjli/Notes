<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BuildAndTestGuideForFWTS.md</title>
    <link href="/2023/09/13/BuildAndTestGuideForFWTS/"/>
    <url>/2023/09/13/BuildAndTestGuideForFWTS/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#firmwaretestsuite-fwts">FirmwareTestSuite (FWTS)</a><ul><li><a href="#install-fwts-tool">Install FWTS tool</a></li><li><a href="#run-and-test">Run and test</a></li><li><a href="#reference-link">Reference Link</a></li></ul></li></ul><h1 id="FirmwareTestSuite-FWTS"><a href="#FirmwareTestSuite-FWTS" class="headerlink" title="FirmwareTestSuite (FWTS)"></a>FirmwareTestSuite (FWTS)</h1><p>官方网站：<a href="https://wiki.ubuntu.com/FirmwareTestSuite">https://wiki.ubuntu.com/FirmwareTestSuite</a><br>项目地址：<a href="https://github.com/ColinIanKing/fwts">https://github.com/ColinIanKing/fwts</a></p><p>Test Range:<br>acpiinfo xenv xsdt wsmt wpbt wmi wdat waet uefi tpm2 tcpa svkl<br>stao srat spmi spcr slit slic sdev sdei sbst rsdt rsdp rgrt rasf pptt pmtt phat<br>pdtt pcct pcc nfit method msdm msct mpst mpam mchi mcfg madt lpit ivrs iort hmat<br>hpet hest gtdt fpdt fadt facs erst einj ecdt drtm dppt dmar acpi_wpc acpi_time<br>acpi_als acpi_nvdimm acpi_lid acpi_slpb acpi_pwrb acpi_ec smart_battery<br>acpi_battery acpi_ac dbg2 dbgp cstates csrt cpep checksum cedt boot bgrt bert<br>aspt asf apicinstance aest acpitables</p><h2 id="Install-FWTS-tool"><a href="#Install-FWTS-tool" class="headerlink" title="Install FWTS tool"></a>Install FWTS tool</h2><p>(Check your OS type, for example, if the OS is CentOS, the OS belongs to RedHat, so configure the dependencies according to RHEL.)</p><ol><li><p>Configure the dependencies for FWTS according to README<br>`sudo yum install autoconf automake kernel-devel libtool flex flex-devel bison dkms</p><pre><code class="hljs">           libfdt libfdt-devel dtc pcre-devel pcre2 pcre2-devel           pcre2-utf16 pcre2-utf32 glib2 glib2-devel pciutils pciutils-devel zlib-devel           make libbsd-devel`</code></pre></li><li><p>Download FWTS source code:<br><code>git clone https://github.com/ColinIanKing/fwts</code></p></li><li><p>Go to the folder<br><code>cd fwts</code></p></li><li><p>To build and install (only if building from source)<br><code>autoreconf -ivf</code><br><code>./configure</code><br><code>make</code><br><code>sudo make install</code></p></li></ol><h2 id="Run-and-test"><a href="#Run-and-test" class="headerlink" title="Run and test"></a>Run and test</h2><blockquote><ul><li>Run all tests<br>sudo fwts</li></ul></blockquote><blockquote><ul><li>Run all ACPI tests and rename the generated file name to RenameResults.log<br>sudo fwts –acpitest -r RenameResults.log</li></ul></blockquote><blockquote><ul><li>Test a single ACPI table<br>sudo fwts SingleTable -r SingleTableResults.log<br>eg: sudo fwts dmar -r DMAR.log</li></ul></blockquote><blockquote><ul><li>Dump related files<br>sudo fwts –dump<br>Instruction: README.txt/dmesg.log/dmidecode.log/lspci.log/acpidump.log/cpuinfo.log will be generated</li></ul></blockquote><h2 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h2><p><a href="https://canonical.com/blog/debug-acpi-tables-with-firmware-test-suite-fwts">https://canonical.com/blog/debug-acpi-tables-with-firmware-test-suite-fwts</a><br><a href="https://canonical.com/blog/analyze-acpi-tables-in-a-text-file-with-fwts">https://canonical.com/blog/analyze-acpi-tables-in-a-text-file-with-fwts</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43.md</title>
    <link href="/2023/08/22/43-md/"/>
    <url>/2023/08/22/43-md/</url>
    
    <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>PCH   Platform Controller Hub</p><p>Socket:     指物理cpu，就是实打实可以拿在手上的那个。比如一个服务器上有要安装2个cpu，也就是2 socket.<br>Core:       核。现在科技发展，cpu通常都是多核。<br>Processor/Thread:  中文叫处理器/线程。processor/thread的数量取决于BIOS setup中会不会打开超线程(hyper-threading)，如果打开超线程的话，那一个core就有2个logic core, 即2个processor. 当然，不打开超线程的话，一个core 只有一个processor.<br>一个物理cpu/socket内部，分为cores部分和uncore modules部分。<br>Register:   寄存器。寄存器位于cpu内部，用于存放程序执行中用到的数据和指令，cpu从寄存器中获取数据，相比从内存中获取快得多。</p><p>在linux下，我们可以通过以下命令来查看当前机器的cpu拓扑结构：<br><img src="image.png" alt="Alt text"><br>由上可见，该机器的主板上有一个cpu插槽（socket），这个插槽上的cpu有2核（core），且每核上又有2个线程（thread），也就是说，这个机器是2核4线程的。<br>上图中thread总数是用cpu来表示的，这也是为什么上文说，cpu是个比较宽泛的概念，在不同的语境下有不同的定义，这里表示的就是逻辑核，也就是thread。</p><h2 id="地址解释"><a href="#地址解释" class="headerlink" title="地址解释"></a>地址解释</h2><p>Physical Address: 物理地址。BIOS在遍历一遍计算机硬件后，将所有硬件的存储空间进行了统一的编址（不算硬盘的存储空间），这个编址就是物理地址。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2023</title>
    <link href="/2023/08/20/2023/"/>
    <url>/2023/08/20/2023/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU-IO-Mem之间的关系"><a href="#CPU-IO-Mem之间的关系" class="headerlink" title="CPU, IO, Mem之间的关系"></a>CPU, IO, Mem之间的关系</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>CPU： 工人，干活的，判断以及逻辑处理<br>内存：车间，工人干活的地方，车间中加工原料，当车间中没有原料了，在从仓库中取原料，对原料进行加工 内存本身有一定的存储空间，对内存中的数据进行处理的速度比从硬盘取数据再处理的速度快很多<br>硬盘：仓库，原料，数据存储</p><h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>CPU对数据进行判断以及逻辑处理，本身不能存储数据，这时cpu从内存取数据进行逻辑计算，如果内存没有数据，才会从硬盘读数据到内存，再对数据进行处理<br>就像人吃饭一样，cpu就是人，内存就是碗，硬盘就是饭锅！<br>当cpu进程等待，会造成内存开销的增加，内存不够用的时候会用到虚拟内存，导致虚拟内存的增加，这时磁盘IO开销就会增加，系统态sy%提升，cpu开销增加；内存里数据不够用，才用磁盘中取数据。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hanjuan666</title>
    <link href="/2023/02/25/111/"/>
    <url>/2023/02/25/111/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hanjuan52</title>
    <link href="/2023/02/25/hanjuansb/"/>
    <url>/2023/02/25/hanjuansb/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
